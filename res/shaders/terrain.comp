#version 450 core

// use float arrays for same packing as on cpu. vec3 would be padded with 1 extra byte
struct Vertex {
    float position[3];
    float texCoord[2];
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(std430, binding = 0) writeonly buffer ssbo1 {
    Vertex vertices[];
};

layout(location = 0) uniform uint buffIdx;
layout(location = 1) uniform ivec2 chunkIdx;
layout(location = 2) uniform ivec2 centerIdx;

layout(location = 3) uniform uint gridSize;
layout(location = 4) uniform uint octaves;
layout(location = 5) uniform float lacunarity;
layout(location = 6) uniform float gain;

vec2 hash(float ix, float iy) {
    const uint w = 32;
    const uint s = w / 2;

    uint a = uint(ix);
    uint b = uint(iy);

    a *= 3284157443u;

    b ^= a << s | a >> (w - s);
    b *= 1911520717;

    a ^= b << s | b >> (w - s);
    a *= 2048419325;
    const float random = a * (3.14159265 / ~(~0u >> 1));

    return vec2(sin(random), cos(random));
}

float dotGridGradient(float ix, float iy, float x, float y) {
    vec2 gradient = hash(ix, iy);
    vec2 dist = vec2(x - ix, y - iy);
    return dot(dist, gradient);
}

float cubicInterp(float a0, float a1, float w) {
    return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;
}

float perlin(float x, float y) {
    vec2 v0 = vec2(floor(x + 0.01), floor(y + 0.01));
    vec2 v1 = vec2(v0.x + 1, v0.y + 1);

    float sx = x - v0.x;
    float sy = y - v0.y;

    float n0 = dotGridGradient(v0.x, v0.y, x, y);
    float n1 = dotGridGradient(v1.x, v0.y, x, y);
    float ix0 = cubicInterp(n0, n1, sx);

    n0 = dotGridGradient(v0.x, v1.y, x, y);
    n1 = dotGridGradient(v1.x, v1.y, x, y);
    float ix1 = cubicInterp(n0, n1, sx);

    return cubicInterp(ix0, ix1, sy);
}

float noise(int x, int z) {
    float val = 0;
    float freq = 1;
    float amp = 1;

    for (int i = 0; i < octaves; i++) {
        val += perlin(x * freq / gridSize, z * freq / gridSize) * amp; 
        freq *= lacunarity;
        amp *= gain;
    }

    val = clamp(val * 1.2, -1.0, 1.0);
    float height = (val + 1.0) * 0.5;
    return height;
}

const int chunkWidth = 1024;

void main() {
    // sort of fix gaps in between chunks
    int xDiff = chunkIdx.x - centerIdx.x;
    int yDiff = chunkIdx.y - centerIdx.y;
    
    const int x = int(gl_GlobalInvocationID.x) + chunkIdx.x * chunkWidth - xDiff;
    const int z = int(gl_GlobalInvocationID.y) + chunkIdx.y * chunkWidth - yDiff;
    const float y = noise(x, z);

    const uint buffOffset = buffIdx * chunkWidth * chunkWidth;
    const uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * chunkWidth + buffOffset;
    vertices[idx] = Vertex(float[3](x, y, z), float[2](0.0, 0.0));
}
